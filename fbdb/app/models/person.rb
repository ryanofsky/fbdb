class Person < ActiveRecord::Base
  set_table_name :PERSONS
  set_primary_key :SSNO
  has_one :phone_address, :foreign_key => :SSNO
  belongs_to :sex_code, :foreign_key => :SEX
  belongs_to :ethnicity, :foreign_key => :ETHNICITY
  has_and_belongs_to_many :events, :join_table => :LINKPERSONSEVENTS, :foreign_key => :SSNO, :association_foreign_key => :EventID

  def to_label
    "#{self.FIRSTNAME} #{self.LASTNAME}"
  end

  def before_save
    if self.EXTENSION == ""
      self.EXTENSION = nil
    end
    if self.SortCode == ""
      self.SortCode = nil
    end
  end

  def SSNO
    ssno = read_attribute :SSNO
    ssno && "#{ssno[0..2]}-#{ssno[3..4]}-#{ssno[5..-1]}"
  end

  # Hack to make it possible to modify SSNO. Hack has two parts:
  #
  # 1) Before update, the "primary" attribute on the SSNO column update
  #    is set to false, so the column will be included in the SQL UPDATE
  #    statement generated by ActiveRecord
  # 2) During the update, the "id" method is overridden to return the
  #    previous SSNO value so it will appear in the WHERE clause of
  #    the SQL UPDATE statement
  #
  # If the update fails, the instance can wind up in an inconsistent
  # state.

  def SSNO=(new_ssno)
    @old_ssno ||= read_attribute :SSNO
    write_attribute :SSNO, new_ssno.gsub(/-/, "")
  end

  def before_update
    if @old_ssno
      self.class.columns_hash["SSNO"].primary = false
      @update_hack = true
    end
  end

  def id
    @update_hack ? @old_ssno : read_attribute(:SSNO)
  end

  def after_update
    if @update_hack
      self.class.columns_hash["SSNO"].primary = true
      @update_hack = @old_ssno = nil
    end
  end

end
